<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Vczyh's Blog</title><link>https://blog-github.zhangeek.com/posts/</link><description>Recent content in Posts on Vczyh's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 28 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog-github.zhangeek.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>位运算及应用</title><link>https://blog-github.zhangeek.com/posts/bit-operation/</link><pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog-github.zhangeek.com/posts/bit-operation/</guid><description>Go支持的位运算 位运算符 示例 说明 |（按位或） a | b 对应位有一个是1则返回1，否则返回0 &amp;amp;（按位与） a &amp;amp; b 对应位都是1则返回1，否则返回0 ^（按位异或） a ^ b 对应位不相同则返回1，否则返回0 &amp;amp;^（Bit clear） a &amp;amp;^ b 结果假设为a，然后a中为1的位和对应b的位都为1，则将a此位置0 &amp;lt;&amp;lt;（左移） a &amp;lt;&amp;lt; n 乘以2^n，将a左移n位，高位丢弃，低位补0 &amp;gt;&amp;gt;（右移） a &amp;gt;&amp;gt; n 除以2^n，将a右移n位，低位丢弃，但高位不是简单的补0（需要注意符号） var tables = []struct { p1 int p2 int symbol string }{ {4, 5, &amp;#34;|&amp;#34;}, {4, 5, &amp;#34;&amp;amp;&amp;#34;}, {4, 5, &amp;#34;^&amp;#34;}, {6, 11, &amp;#34;&amp;amp;^&amp;#34;}, {4, 2, &amp;#34;&amp;lt;&amp;lt;&amp;#34;}, {4, 1, &amp;#34;&amp;gt;&amp;gt;&amp;#34;}, } for _, t := range tables { var result int switch t.</description></item><item><title>使用Linux Logrotate切割日志</title><link>https://blog-github.zhangeek.com/posts/logrotate/</link><pubDate>Mon, 26 Jul 2021 23:00:00 +0800</pubDate><guid>https://blog-github.zhangeek.com/posts/logrotate/</guid><description>logrotate可以管理日志文件，可以根据日期切割、根据日志文件大小切割、自动删除超过一定时间的归档日志。
安装 测试环境为 。
CentOS Linux release 8.2.2004 (Core) 其他系统类似，请先检查logrotate是否安装，一切以文档为准。
man logrotate 使用 首先创建一个日志文件。
mkdir /var/log/logrotate-test # 创建日志文件，并添加一些信息 seq 10 &amp;gt; /var/log/logrotate-test/access.log 创建logrotate配置文件，格式是这样的。
日志文件绝对路径（可以使用通配符*） { 指令1 指令2 ... } logrotate全局配置文件位于/etc/logrotate.conf，自定义配置文件位于/etc/logrotate.d/。
一个具体的例子，表示每天切割日志，并压缩存档，最多保存5份存档（按时间排序，较早的删除），切割日志后自动创建新的日志文件，存档日志以时间为后缀。
&amp;gt; vim /etc/logrotate.d/logrotate-test /var/log/logrotate-test/access.log { daily compress rotate 5 create dateext } 由于定时任务未到，需要手动通知logrotate执行切割任务。
logrotate -vf /etc/logrotate.d/logrotate-test &amp;gt; ll /var/log/logrotate-test total 4 -rw-r--r--. 1 root root 0 Nov 13 20:17 access.log -rw-r--r--. 1 root root 41 Nov 13 20:15 access.log-20201113.gz 基本使用就是这样，为了验证，你可以等待几天看看切割结果。除此之外，logrotate还有其他指令，比如可以在每次切割后执行命令，这里往日志文件添加新的记录。</description></item><item><title>Go Channel</title><link>https://blog-github.zhangeek.com/posts/go-channel/</link><pubDate>Sun, 26 Jul 2020 11:20:24 +0800</pubDate><guid>https://blog-github.zhangeek.com/posts/go-channel/</guid><description>无缓冲通道 func main() { c := make(chan int) go func() { time.Sleep(3 * time.Second) fmt.Println(&amp;#34;receive&amp;#34;) fmt.Println(&amp;lt;-c) }() c &amp;lt;- 1 fmt.Println(&amp;#34;send&amp;#34;) } 执行结果。
receive 1 send 对于无缓冲通道，必须得send goroutine和receive goroutine双方都得准备好，如果两个 goroutine没有同时准备好，通道会导致先执行send或receive操作的goroutine阻塞等待。
这意味着执行c&amp;lt;-1时，发现没有receive方，于是阻塞等待，这就解释了为什么以上主程序执行到c&amp;lt;-1，然后阻塞，同时另一个goroutine三秒后打印，从channel中取值，最后主程序结束。
有缓冲通道 有缓冲通道有一个缓冲区，这个大小在声明时指定。所以他不要求goroutine同时完成send和receive，只有缓冲区满的时候，send操作才会阻塞，只有缓冲区空的时候，receive操作才会阻塞，试着为上面程序的通道加上缓冲区。
func main() { c := make(chan int, 1) go func() { time.Sleep(3 * time.Second) fmt.Println(&amp;#34;receive&amp;#34;) fmt.Println(&amp;lt;-c) }() c &amp;lt;- 1 fmt.Println(&amp;#34;send&amp;#34;) } 执行结果。
send</description></item><item><title>Java SPI</title><link>https://blog-github.zhangeek.com/posts/java-spi/</link><pubDate>Thu, 26 Mar 2020 11:20:24 +0800</pubDate><guid>https://blog-github.zhangeek.com/posts/java-spi/</guid><description>SPI 简介 SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI的本质是将接口实现类（可以是一个或多个）配置在文件中，然后服务读取配置文件，加载指定接口的实现类。利用 SPI 机制很容易为程序提供拓展功能，使程序解耦。
SPI 可以分为 Java SPI 和框架自定义的 SPI，例如 Spring、Dubbo。
Java SPI 示例 本节通过一个示例演示 Java SPI 的使用方法，首先定义一个接口，名称为 Device。
public interface Device { void say(); } 接下来定义两个实现类，分别为 Computer 和 Phone。
public class Computer implements Device { @Override public void say() { System.out.println(&amp;#34;Hello, I am Computer&amp;#34;); } } public class Phone implements Device { @Override public void say() { System.out.println(&amp;#34;Hello, I am Phone&amp;#34;); } } 接下来在META-INF/services文件夹下创建一个文件，名称为 Device 的全限定名 com.</description></item></channel></rss>