<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Vczyh's Blog</title><link>https://blog-github.zhangeek.com/tags/go/</link><description>Recent content in Go on Vczyh's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 26 Jul 2020 11:20:24 +0800</lastBuildDate><atom:link href="https://blog-github.zhangeek.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Channel</title><link>https://blog-github.zhangeek.com/posts/go-channel/</link><pubDate>Sun, 26 Jul 2020 11:20:24 +0800</pubDate><guid>https://blog-github.zhangeek.com/posts/go-channel/</guid><description>无缓冲通道 func main() { c := make(chan int) go func() { time.Sleep(3 * time.Second) fmt.Println(&amp;#34;receive&amp;#34;) fmt.Println(&amp;lt;-c) }() c &amp;lt;- 1 fmt.Println(&amp;#34;send&amp;#34;) } 执行结果。
receive 1 send 对于无缓冲通道，必须得send goroutine和receive goroutine双方都得准备好，如果两个 goroutine没有同时准备好，通道会导致先执行send或receive操作的goroutine阻塞等待。
这意味着执行c&amp;lt;-1时，发现没有receive方，于是阻塞等待，这就解释了为什么以上主程序执行到c&amp;lt;-1，然后阻塞，同时另一个goroutine三秒后打印，从channel中取值，最后主程序结束。
有缓冲通道 有缓冲通道有一个缓冲区，这个大小在声明时指定。所以他不要求goroutine同时完成send和receive，只有缓冲区满的时候，send操作才会阻塞，只有缓冲区空的时候，receive操作才会阻塞，试着为上面程序的通道加上缓冲区。
func main() { c := make(chan int, 1) go func() { time.Sleep(3 * time.Second) fmt.Println(&amp;#34;receive&amp;#34;) fmt.Println(&amp;lt;-c) }() c &amp;lt;- 1 fmt.Println(&amp;#34;send&amp;#34;) } 执行结果。
send</description></item></channel></rss>