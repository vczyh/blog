---
title: Java内存区域与内存溢出异常
date: 2020-02-18
tags: 
  - Java
  - JVM
---



### 运行时数据区域

| 数据区     | 线程共享/线程隔离 | 异常                                 |
| ---------- | ----------------- | ------------------------------------ |
| 程序计数器 | 线程隔离          | 没有                                 |
| 虚拟机栈   | 线程隔离          | StackOverflowError和OutOfMemoryError |
| 本地方法栈 | 线程隔离          | StackOverflowError和OutOfMemoryError |
| 方法区     | 线程共享          | OutOfMemoryError                     |
| 堆         | 线程共享          | OutOfMemoryError                     |

### 程序计数器

- 较小的内存空间
- 当前线程所执行字节码的行号指示器
- 分支、循环、跳转、异常处理、线程恢复依赖计数器
- 线程执行Java方法，计数器的记录是正在执行的虚拟机字节码指令的地址
- 线程执行Native方法，计数器的记录为空
- 唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

### Java虚拟机栈

- 描述的是Java方法执行的内存模型
- 每个方法执行时会创建一个栈帧用于**存储局部变量表**、**操作数栈**、**动态链接**、**方法出**口等信息。
- 每个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出站的过程
  - 局部变量存放了编译期可知的各种**基本数据类型**(boolean、byte、char、short、int、float、long、double)、**对象引用**(reference类型，它可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置)和**returnAddress类型**(指向了一条字节码指令的地址)
  - 64位的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个
  - 局部变量表所需的内存在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小
- 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError
- 虚拟机栈动态扩展时无法申请到足够的内存，抛出OutOfMemoryError

### 本地方法栈

- 语虚拟机栈相似(Native方法)
- 虚拟机规范没有对本地方法栈进行强行规定
- Sun HotSpot虚拟机把本地方法栈和虚拟机栈合二为一
- 会抛出StackOverflowError和OutOfMemoryError

### Java堆

- 存放对象实例以及数组，但随着JIT编译器的发展与逃逸分析技术逐渐成熟、栈上分配、标量替换优化技术使得前者没那么绝对
- 垃圾收集器管理的主要区域，因此也被称作GC堆
- 现在收集器基本都采用分代收集算法
- 可以分为：新生代和老年代
- 还可以细分为：Eden空间、From survivor、To Survivor空间
- Java堆可能划分出多个线程私有的分配缓冲区(TLAB)，可以更快的分配内存和回收内存
- Java堆可以是在物理不连续内存空间，只要逻辑上是连续的即可

### 方法区

- 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 别名——非堆
- HotSpot对方法区的实现是永久代，方便垃圾收集器可以像管理Java堆一样管理方法区

> JDK7的HotSpot中，已经把原本放在永久代的字符串常量池移出，JDK8的HotSpot中，已经放弃永久代，实现改成metaspace

### 运行时常量池

- 是方法区的一部分
- 用于存放编译期生成的各种字面量和符号引用
- 运行期间也可能将新的常量放入池中，例如String类的intern()方法

### 直接内存

- 直接内存不是虚拟机运行时数据区的一部分
- 它可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuff对象作为这块内存的引用进行操作，不受Java堆大小的限制，避免了在Java堆和Native堆中来回复制数据。
- 可能抛出OutOfMemoryError

### 对象

- 对象创建
  - 遇到new指令，首先检查指令的参数能否在常量池中定位到一个类的符号引用
  - 检查符号引用代表的类是否已被加载、解析和初始化过，如果没有必须先执行相应的类加载过程
  - 为对象分配内存，对象所需内存大小在类加载完后便可以确定
    - Java堆绝对规整(所有用过的内存都放在一边，空闲的内存放在另一边)，已分配内存的末尾放个指针，分配内存就是把指针向空闲区域移动对象大小距离，这种分配方式称为”指针碰撞“
    - Java堆不规整，虚拟机会维护一个列表，记录哪些内存可用，分配时从列表找出一块足够大的空间分配给实例，并更新列表记录，这种分配方式称为”空闲列表“
    - 压缩整理功能可以使Java堆绝对规整
    - 并发：正在给对象A分配内存，指针还没修改，对象B又使用原来的指针分配内存
      - 措施一：CAS+失败重试
      - 措施二：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)，只有TLAB用完并分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB可以通过-XX:+/-UseTLAB参数设定
  - 内存分配完后，初始化为零值(不包括对象头)，这一步保证了对象实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值
  - 设置对象头：哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄
  - 执行 `<init>` 方法，把对象按照程序员的意愿进行初始化
- 对象的内存布局：对象头、实例数据、对齐填充
  - 对象头：运行时数据、类型指针
    - 运行时数据：哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，称为“Mark Word”
    - 类型指针：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都在对象数据上保留类型指针，也就是查找对象的元数据信息不一定要通过对象本身。如果对象是数组，在对象头还必须有一块用于记录数组长度的数据，因为通过普通Java对象的元数据可以确定对象大小，但是通过数组的元数据不能确定数组大小
  - 实例数据：真正的有效信息，也就是在代码中定义的各种类型的字段内容
  - 对齐填充：不是必然存在，起着占位符的作用。HotSpot要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍
- 对象的访问定位：句柄和直接指针
  - 使用句柄：Java堆会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址。优点是如果对象移动，只会修改句柄，reference不变
  - 使用直接指针：reference中存储的直接就是对象地址。优点是速度快

